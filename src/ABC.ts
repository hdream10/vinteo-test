// Что было плохо и почему:
// Транзитивное обращение. Прииводит к низкой читаемости, трудности в тестировании и отладке.
// Классы ответственны не только за свою логику, но и за сосздание экземпляра другого класс.

// Что стало лучше и почему:
// Избавлились от транзитивного обращения. Внесли изменения, чтобы каждый класс выполнял только свою задачу,
// а зависимости инжектировались через конструкторы.
// Это улучшает читаемость, упрощает тестирование и делает код более гибким.

class A {
  private b: B;

  constructor(b: B) {
    this.b = b;
  }

  getB() {
    return this.b;
  }
}

class B {
  private c: C;

  constructor(c: C) {
    this.c = c;
  }

  getC() {
    return this.c;
  }
}

class C {
  doSomething() {
    // Логика
  }
}

const c = new C();
const b = new B(c);
const a = new A(b);

a.getB().getC().doSomething();
